name: Kaggle Script Action
description: Run Python scripts on Kaggle kernels with configurable GPU/TPU/internet options.
author: Kevin Kibe 

inputs:
  username:
    description: Your Kaggle username
    required: true
  key:
    description: Your Kaggle API key
    required: true
  title:
    description: Title for the Kaggle kernel
    required: true
  custom_script:
    description: Python command(s) to run inside the kernel
    required: false
    default: |
      print("Hello, world from default script!")
  enable_gpu:
    description: Enable GPU for the kernel (true/false)
    required: false
    default: "true"
  enable_tpu:
    description: Enable TPU for the kernel (true/false)
    required: false
    default: "false"
  enable_internet:
    description: Enable internet access for the kernel (true/false)
    required: false
    default: "true"
  working_subdir: 
    description: Subdirectory containing your script 
    required: false
    default: ""
  dataset_sources:
    description: Comma-separated list of dataset sources 
    required: false
    default: ""
  competition_sources:
    description: Comma-separated list of competition sources
    required: false
    default: ""
  kernel_sources:
    description: Comma-separated list of kernel sources
    required: false
    default: ""
  sleep_time:
    description: Time in seconds to wait between kernel status checks
    required: false
    default: "10"

runs:
  using: "composite"
  steps:
    - name: Install dependencies for the action runner
      shell: bash
      run: |
        pip install kaggle jq

    - name: Set up Kaggle API token
      shell: bash
      run: |
        mkdir -p ~/.kaggle
        echo "{\"username\":\"${{ inputs.username }}\",\"key\":\"${{ inputs.key }}\"}" > ~/.kaggle/kaggle.json
        chmod 600 ~/.kaggle/kaggle.json

    - name: Generate notebook
      shell: bash
      run: |

        
        NOTEBOOK_FILE=script.ipynb

        ESCAPED_SCRIPT=$(echo "${{ inputs.custom_script }}" | jq -R -s 'split("\n")')

        cat <<-END_OF_NOTEBOOK_CONTENT > $NOTEBOOK_FILE
        {
          "cells": [
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": $ESCAPED_SCRIPT
            }
          ],
          "metadata": {
            "kernelspec": {
              "display_name": "Python 3",
              "language": "python",
              "name": "python3"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }
        END_OF_NOTEBOOK_CONTENT 

    - name: Create kernel metadata
      shell: bash
      run: |
        KERNEL_ID="${{ inputs.username }}/$(echo "${{ inputs.title }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--/-/g')"
        jq -n \
          --arg id "$KERNEL_ID" \
          --arg title "${{ inputs.title }}" \
          --arg code_file "script.ipynb" \
          --argjson enable_gpu $([[ "${{ inputs.enable_gpu }}" == "true" ]] && echo true || echo false) \
          --argjson enable_tpu $([[ "${{ inputs.enable_tpu }}" == "true" ]] && echo true || echo false) \
          --argjson enable_internet $([[ "${{ inputs.enable_internet }}" == "true" ]] && echo true || echo false) \
          --arg dataset_sources "${{ inputs.dataset_sources }}" \
          --arg competition_sources "${{ inputs.competition_sources }}" \
          --arg kernel_sources "${{ inputs.kernel_sources }}" \
          '
          {
            id: $id,
            title: $title,
            code_file: $code_file,
            language: "python",
            kernel_type: "notebook",
            is_private: false, # Consider making this an input
            enable_gpu: $enable_gpu,
            enable_tpu: $enable_tpu,
            enable_internet: $enable_internet,
            dataset_sources: ($dataset_sources | split(",") | map(select(. != ""))),
            competition_sources: ($competition_sources | split(",") | map(select(. != ""))),
            kernel_sources: ($kernel_sources | split(",") | map(select(. != "")))
          }
          ' > kernel-metadata.json

    - name: Push to Kaggle
      shell: bash
      run: kaggle kernels push -p .

    - name: Wait for execution
      shell: bash
      run: |
        KERNEL_ID="${{ inputs.username }}/$(echo "${{ inputs.title }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--/-/g')"
        echo "⌛ Waiting for kernel ($KERNEL_ID) to execute..."
        # Initial sleep to allow Kaggle to process the push
        sleep_duration=${{ inputs.sleep_time }}
        sleep "$sleep_duration"
        
        max_attempts=30 # Approx 5 minutes if sleep_time is 10s
        attempt_num=0

        while true; do
          ((attempt_num++))
          if ((attempt_num > max_attempts)); then
            echo "❌ Maximum attempts reached. Kernel status check timed out."
            kaggle kernels output "$KERNEL_ID" || echo "Failed to get kernel output on timeout."
            exit 1
          fi

          # Fetch status, redirecting stderr to stdout to capture all output from kaggle CLI
          status_output=$(kaggle kernels status "$KERNEL_ID" 2>&1)
          echo "Attempt $attempt_num: Status: $status_output"

          # Check for various terminal states
          if echo "$status_output" | grep -q "complete"; then
            echo "✅ Execution complete for $KERNEL_ID"
            kaggle kernels output "$KERNEL_ID" # Fetch final output
            break
          elif echo "$status_output" | grep -qE "error|failed|cancelled|cancelRequested"; then # Added more failure states
            echo "❌ Kernel $KERNEL_ID failed or was cancelled. Status: $status_output"
            kaggle kernels output "$KERNEL_ID" || echo "Failed to get kernel output on failure."
            exit 1
          elif echo "$status_output" | grep -q "has no run"; then # Kernel might not have started yet
             echo "⏳ Kernel $KERNEL_ID has no run yet, or metadata issue. Waiting..."
          elif echo "$status_output" | grep -q "not found"; then
             echo "❌ Kernel $KERNEL_ID not found. Check title and username. Waiting for potential propagation..."
          fi
          echo "⏳ Still processing, checking again in $sleep_duration seconds..."
          sleep "$sleep_duration"
        done