name: Kaggle Script Action
description: Run Python scripts on Kaggle kernels with configurable GPU/TPU/internet options.
author: Kevin Kibe

inputs:
  username:
    description: Your Kaggle username
    required: true
  key:
    description: Your Kaggle API key
    required: true
  title:
    description: Title for the Kaggle kernel
    required: true
  custom_script:
    description: Python command(s) to run inside the kernel
    required: false
    default: |
      print("Hello, world from default script!")
  enable_gpu:
    description: Enable GPU for the kernel (true/false)
    required: false
    default: "true"
  enable_tpu:
    description: Enable TPU for the kernel (true/false)
    required: false
    default: "false"
  enable_internet:
    description: Enable internet access for the kernel (true/false)
    required: false
    default: "true"
  working_subdir:
    description: Subdirectory containing your script (currently unused in this version)
    required: false
    default: ""
  dataset_sources:
    description: Comma-separated list of dataset sources (e.g., username/dataset-slug)
    required: false
    default: ""
  competition_sources:
    description: Comma-separated list of competition sources
    required: false
    default: ""
  kernel_sources:
    description: Comma-separated list of kernel sources
    required: false
    default: ""
  sleep_time:
    description: Time in seconds to wait between kernel status checks
    required: false
    default: "10"

runs:
  using: "composite"
  steps:
    - name: Install dependencies for the action runner
      shell: bash
      run: |
        pip install kaggle jq

    - name: Set up Kaggle API token
      shell: bash
      run: |
        mkdir -p ~/.kaggle
        echo "{\"username\":\"${{ inputs.username }}\",\"key\":\"${{ inputs.key }}\"}" > ~/.kaggle/kaggle.json
        chmod 600 ~/.kaggle/kaggle.json

    - name: Generate notebook
      shell: bash
      run: |
        NOTEBOOK_FILE=script.ipynb
        # Properly escape the script for JSON inclusion
        ESCAPED_SCRIPT=$(echo '${{ inputs.custom_script }}' | jq -Rs 'split("\n")')

        cat <<EOF > "$NOTEBOOK_FILE"
        {
          "cells": [
            {
              "cell_type": "code",
              "execution_count": null,
              "metadata": {},
              "outputs": [],
              "source": $ESCAPED_SCRIPT
            }
          ],
          "metadata": {
            "kernelspec": {
              "display_name": "Python 3",
              "language": "python",
              "name": "python3"
            }
          },
          "nbformat": 4,
          "nbformat_minor": 2
        }
        EOF

    - name: Create kernel metadata
      shell: bash
      run: |
        KERNEL_ID="${{ inputs.username }}/$(echo "${{ inputs.title }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--/-/g')"
        # Fix - use heredoc with explicit EOF marker instead of quotes to avoid JSON parsing issues
        cat > kernel-metadata.json << EOF
        {
          "id": "$KERNEL_ID",
          "title": "${{ inputs.title }}",
          "code_file": "script.ipynb",
          "language": "python",
          "kernel_type": "notebook",
          "is_private": false,
          "enable_gpu": $([ "${{ inputs.enable_gpu }}" = "true" ] && echo "true" || echo "false"),
          "enable_tpu": $([ "${{ inputs.enable_tpu }}" = "true" ] && echo "true" || echo "false"),
          "enable_internet": $([ "${{ inputs.enable_internet }}" = "true" ] && echo "true" || echo "false"),
          "dataset_sources": [$([ -n "${{ inputs.dataset_sources }}" ] && echo "\"$(echo '${{ inputs.dataset_sources }}' | sed 's/,/","/g')\"" || echo "")],
          "competition_sources": [$([ -n "${{ inputs.competition_sources }}" ] && echo "\"$(echo '${{ inputs.competition_sources }}' | sed 's/,/","/g')\"" || echo "")],
          "kernel_sources": [$([ -n "${{ inputs.kernel_sources }}" ] && echo "\"$(echo '${{ inputs.kernel_sources }}' | sed 's/,/","/g')\"" || echo "")]
        }
        EOF
        
        # Output the metadata file for debugging
        echo "Generated kernel-metadata.json:"
        cat kernel-metadata.json

    - name: Push to Kaggle
      shell: bash
      run: |
        kaggle kernels push -p .

    - name: Wait for execution
      shell: bash
      run: |
        KERNEL_ID="${{ inputs.username }}/$(echo "${{ inputs.title }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--/-/g')"
        echo "⌛ Waiting for kernel ($KERNEL_ID) to execute..."
        sleep_duration=${{ inputs.sleep_time }}
        sleep "$sleep_duration"

        max_attempts=30
        attempt_num=0

        while true; do
          ((attempt_num++))
          if ((attempt_num > max_attempts)); then
            echo "❌ Maximum attempts reached. Kernel status check timed out."
            kaggle kernels output "$KERNEL_ID" || echo "Failed to get kernel output on timeout."
            exit 1
          fi

          status_output=$(kaggle kernels status "$KERNEL_ID" 2>&1)
          echo "Attempt $attempt_num: Status: $status_output"

          if echo "$status_output" | grep -q "complete"; then
            echo "✅ Execution complete for $KERNEL_ID"
            kaggle kernels output "$KERNEL_ID"
            break
          elif echo "$status_output" | grep -qE "error|failed|cancelled|cancelRequested"; then
            echo "❌ Kernel $KERNEL_ID failed or was cancelled. Status: $status_output"
            kaggle kernels output "$KERNEL_ID" || echo "Failed to get kernel output on failure."
            exit 1
          elif echo "$status_output" | grep -q "has no run"; then
            echo "⏳ Kernel $KERNEL_ID has no run yet. Waiting..."
          elif echo "$status_output" | grep -q "not found"; then
            echo "❌ Kernel $KERNEL_ID not found. Check title and username."
          fi

          echo "⏳ Still processing, checking again in $sleep_duration seconds..."
          sleep "$sleep_duration"
        done